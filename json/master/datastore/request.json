[
  {
    "tags": [],
    "description": {
      "full": "<p>Copyright 2014 Google Inc. All Rights Reserved.</p><p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br />you may not use this file except in compliance with the License.<br />You may obtain a copy of the License at</p><pre><code> http://www.apache.org/licenses/LICENSE-2.0\n</code></pre><p>Unless required by applicable law or agreed to in writing, software<br />distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br />WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br />See the License for the specific language governing permissions and<br />limitations under the License.</p>",
      "summary": "<p>Copyright 2014 Google Inc. All Rights Reserved.</p>",
      "body": "<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br />you may not use this file except in compliance with the License.<br />You may obtain a copy of the License at</p><pre><code> http://www.apache.org/licenses/LICENSE-2.0\n</code></pre><p>Unless required by applicable law or agreed to in writing, software<br />distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br />WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br />See the License for the specific language governing permissions and<br />limitations under the License.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1,
    "codeStart": 16
  },
  {
    "tags": [
      {
        "type": "module",
        "string": "datastore/request",
        "html": "<p>datastore/request</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 17,
    "codeStart": 21,
    "code": "'use strict';\n\nvar request = require('request').defaults({\n  pool: {\n    maxSockets: Infinity\n  }\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:datastore/entity}",
        "types": [
          "module:datastore/entity"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fentity.html\">datastore/entity</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:datastore/entity}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 29,
    "codeStart": 33,
    "code": "var entity = require('./entity.js');",
    "ctx": {
      "type": "declaration",
      "name": "entity",
      "value": "require('./entity.js')",
      "string": "entity"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:datastore/pb}",
        "types": [
          "module:datastore/pb"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fpb.html\">datastore/pb</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:datastore/pb}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 35,
    "codeStart": 39,
    "code": "var pb = require('./pb.js');",
    "ctx": {
      "type": "declaration",
      "name": "pb",
      "value": "require('./pb.js')",
      "string": "pb"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:common/streamrouter}",
        "types": [
          "module:common/streamrouter"
        ],
        "typesDescription": "module:<a href=\"module%3Acommon%2Fstreamrouter.html\">common/streamrouter</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:common/streamrouter}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 41,
    "codeStart": 45,
    "code": "var streamRouter = require('../common/stream-router.js');",
    "ctx": {
      "type": "declaration",
      "name": "streamRouter",
      "value": "require('../common/stream-router.js')",
      "string": "streamRouter"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:common/util}",
        "types": [
          "module:common/util"
        ],
        "typesDescription": "module:<a href=\"module%3Acommon%2Futil.html\">common/util</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:common/util}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 47,
    "codeStart": 51,
    "code": "var util = require('../common/util.js');",
    "ctx": {
      "type": "declaration",
      "name": "util",
      "value": "require('../common/util.js')",
      "string": "util"
    }
  },
  {
    "tags": [
      {
        "type": "const",
        "string": "{string} Non-transaction mode key.",
        "html": "<p>{string} Non-transaction mode key.</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 53,
    "codeStart": 57,
    "code": "var MODE_NON_TRANSACTIONAL = 'NON_TRANSACTIONAL';",
    "ctx": {
      "type": "declaration",
      "name": "MODE_NON_TRANSACTIONAL",
      "value": "'NON_TRANSACTIONAL'",
      "string": "MODE_NON_TRANSACTIONAL"
    }
  },
  {
    "tags": [
      {
        "type": "const",
        "string": "{string} Transaction mode key.",
        "html": "<p>{string} Transaction mode key.</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 59,
    "codeStart": 63,
    "code": "var MODE_TRANSACTIONAL = 'TRANSACTIONAL';",
    "ctx": {
      "type": "declaration",
      "name": "MODE_TRANSACTIONAL",
      "value": "'TRANSACTIONAL'",
      "string": "MODE_TRANSACTIONAL"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "// This is how to create a transaction object directly using this Transaction\n// class. The following transaction object is created for use in the examples\n// in this file below.\nvar dataset = gcloud.datastore.dataset({ projectId: 'project-id' });\nvar Transaction = require('gcloud/lib/datastore/transaction');\nvar transaction = new Transaction(dataset, 'my-project-id');\ntransaction.id = '1234'; // Give the transaction an ID.",
        "html": "<p>// This is how to create a transaction object directly using this Transaction<br />// class. The following transaction object is created for use in the examples<br />// in this file below.<br />var dataset = gcloud.datastore.dataset({ projectId: &#39;project-id&#39; });<br />var Transaction = require(&#39;gcloud/lib/datastore/transaction&#39;);<br />var transaction = new Transaction(dataset, &#39;my-project-id&#39;);<br />transaction.id = &#39;1234&#39;; // Give the transaction an ID.</p>"
      }
    ],
    "description": {
      "full": "<p>Developer Documentation</p><p>Handles request logic for Datastore.</p><p>Creates requests to the Dataset endpoint. Designed to be inherited by<br />datastore.Dataset and datastore.Transaction objects.</p>",
      "summary": "<p>Developer Documentation</p>",
      "body": "<p>Handles request logic for Datastore.</p><p>Creates requests to the Dataset endpoint. Designed to be inherited by<br />datastore.Dataset and datastore.Transaction objects.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 65,
    "codeStart": 81
  },
  {
    "tags": [
      {
        "type": "constructor",
        "string": "",
        "html": ""
      },
      {
        "type": "alias",
        "string": "module:datastore/request",
        "html": "<p>module:datastore/request</p>"
      },
      {
        "type": "mixin",
        "string": "",
        "html": ""
      }
    ],
    "description": {
      "full": "<p>Handle logic for Datastore API operations.</p>",
      "summary": "<p>Handle logic for Datastore API operations.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": true,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 81,
    "codeStart": 88,
    "code": "function DatastoreRequest() {}",
    "ctx": {
      "type": "constructor",
      "name": "DatastoreRequest",
      "string": "DatastoreRequest()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Key|Key[]} keys - Datastore key object(s).",
        "name": "keys",
        "description": "<ul>\n<li>Datastore key object(s).</li>\n</ul>\n",
        "types": [
          "Key",
          "Array.<Key>"
        ],
        "typesDescription": "<a href=\"Key.html\">Key</a>|<code>Array</code>.&lt;<a href=\"Key.html\">Key</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or Transaction object.\n//-\n\n// Get a single entity.\nvar key = dataset.key(['Company', 123]);\ntransaction.get(key, function(err, entity, apiResponse) {});\n\n// Get multiple entities at once.\ntransaction.get([\n  dataset.key(['Company', 123]),\n  dataset.key(['Product', 'Computer'])\n], function(err, entities, apiResponse) {});",
        "html": "<p>//-<br />// Where you see <code>transaction</code>, assume this is the context that&#39;s relevant to<br />// your use, whether that be a Dataset or Transaction object.<br />//-</p><p>// Get a single entity.<br />var key = dataset.key([&#39;Company&#39;, 123]);<br />transaction.get(key, function(err, entity, apiResponse) {});</p><p>// Get multiple entities at once.<br />transaction.get([<br />  dataset.key([&#39;Company&#39;, 123]),<br />  dataset.key([&#39;Product&#39;, &#39;Computer&#39;])<br />], function(err, entities, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Retrieve the entities identified with the specified key(s) in the current<br />transaction. Get operations require a valid key to retrieve the<br />key-identified entity from Datastore.</p>",
      "summary": "<p>Retrieve the entities identified with the specified key(s) in the current<br />transaction. Get operations require a valid key to retrieve the<br />key-identified entity from Datastore.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 90,
    "codeStart": 114,
    "code": "DatastoreRequest.prototype.get = function(keys, callback) {\n  var that = this;\n\n  var isMultipleRequest = Array.isArray(keys);\n  keys = isMultipleRequest ? keys : [keys];\n\n  callback = callback || util.noop;\n\n  var req = {\n    key: keys.map(entity.keyToKeyProto)\n  };\n\n  this.makeReq_('lookup', req, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var found = entity.formatArray(resp.found);\n\n    if (isMultipleRequest && resp.deferred && resp.deferred.length) {\n      // There may be more results. Call `.get` again, and append the results.\n      that.get(\n          resp.deferred.map(entity.keyFromKeyProto), function(err, entities) {\n        if (err) {\n          callback(err, null, resp);\n          return;\n        }\n\n        if (resp) {\n          found = (found || []).concat(entities);\n        }\n\n        callback(null, found, resp);\n      });\n\n      return;\n    }\n\n    callback(null, isMultipleRequest ? found : found[0], resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "get",
      "string": "DatastoreRequest.prototype.get()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>insert</code>.</p>",
      "summary": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>insert</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 157,
    "codeStart": 160,
    "code": "DatastoreRequest.prototype.insert = function(entities, callback) {\n  entities = util.arrayize(entities).map(util.propAssign('method', 'insert'));\n  this.save(entities, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "insert",
      "string": "DatastoreRequest.prototype.insert()"
    }
  },
  {
    "tags": [
      {
        "type": "borrows",
        "string": "{module:datastore/transaction#save} as save\n",
        "otherMemberName": "{module:datastore/transaction#save}",
        "thisMemberName": "save ",
        "html": "<p>{module:datastore/transaction#save} as save</p>"
      },
      {
        "type": "param",
        "string": "{object|object[]} entities - Datastore key object(s).",
        "name": "entities",
        "description": "<ul>\n<li>Datastore key object(s).</li>\n</ul>\n",
        "types": [
          "object",
          "Array.<object>"
        ],
        "typesDescription": "<code>object</code>|<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Key} entities.key - Datastore key object.",
        "name": "entities.key",
        "description": "<ul>\n<li>Datastore key object.</li>\n</ul>\n",
        "types": [
          "Key"
        ],
        "typesDescription": "<a href=\"Key.html\">Key</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string=} entities.method - Optional method to explicity use for save.\n    The choices include 'insert', 'update', 'upsert' and 'auto_insert_id'.",
        "name": "entities.method",
        "description": "<ul>\n<li>Optional method to explicity use for save.     The choices include &#39;insert&#39;, &#39;update&#39;, &#39;upsert&#39; and &#39;auto_insert_id&#39;.</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object|object[]} entities.data - Data to save with the provided key.\n    If you provide an array of objects, you must use the explicit syntax:\n    `name` for the name of the property and `value` for its value. You may\n    also specify an `excludeFromIndexes` property, set to `true` or `false`.",
        "name": "entities.data",
        "description": "<ul>\n<li>Data to save with the provided key.     If you provide an array of objects, you must use the explicit syntax:<br />  <code>name</code> for the name of the property and <code>value</code> for its value. You may<br />  also specify an <code>excludeFromIndexes</code> property, set to <code>true</code> or <code>false</code>.</li>\n</ul>\n",
        "types": [
          "object",
          "Array.<object>"
        ],
        "typesDescription": "<code>object</code>|<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Save a single entity.\n//\n// Notice that we are providing an incomplete key. After saving, the original\n// Key object used to save will be updated to contain the path with its\n// generated ID.\n//-\nvar key = dataset.key('Company');\n\ndataset.save({\n  key: key,\n  data: {\n    rating: '10'\n  }\n}, function(err) {\n  console.log(key.path); // [ 'Company', 5669468231434240 ]\n  console.log(key.namespace); // undefined\n});\n\n//-\n// Save a single entity using a provided name instead of auto-generated ID.\n//\n// Here we are providing a key with name instead of an ID. After saving, the\n// original Key object used to save will be updated to contain the path with\n// the name instead of a generated ID.\n//-\nvar key = dataset.key(['Company', 'donutshack']);\n\ndataset.save({\n  key: key,\n  data: {\n    name: 'DonutShack',\n    rating: 8\n  }\n}, function(err) {\n  console.log(key.path); // ['Company', 'donutshack']\n  console.log(key.namespace); // undefined\n});\n\n//-\n// Save a single entity with a provided namespace. Namespaces allow for\n// multitenancy. To read more about this, see\n// [the Datastore docs on key concepts](https://goo.gl/M1LUAu).\n//\n// Here we are providing a key with namespace.\n//-\nvar key = dataset.key({\n  namespace: 'my-namespace',\n  path: ['Company', 'donutshack']\n});\n\ndataset.save({\n  key: key,\n  data: {\n    name: 'DonutShack',\n    rating: 8\n  }\n}, function(err) {\n  console.log(key.path); // ['Company', 'donutshack']\n  console.log(key.namespace); // 'my-namespace'\n});\n\n//-\n// Save different types of data, including ints, doubles, dates, booleans,\n// blobs, and lists.\n//\n// Notice that we are providing an incomplete key. After saving, the original\n// Key object used to save will be updated to contain the path with its\n// generated ID.\n//-\nvar key = dataset.key('Company');\n\ndataset.save({\n  key: key,\n  data: {\n    name: 'DonutShack', // strings\n    rating: gcloud.datastore.int(8), // ints\n    worth: gcloud.datastore.double(123456.78), // doubles\n    numDonutsServed: 45, // detect number type (int or double)\n    founded: new Date('Tue May 12 2015 15:30:00 GMT-0400 (EDT)'), // dates\n    isStartup: true, // booleans\n    donutEmoji: new Buffer('\\uD83C\\uDF69'), // buffers\n    keywords: [ 'donut', 'coffee', 'yum' ] // lists of objects\n  }\n}, function(err) {});\n\n//-\n// To specify an `excludeFromIndexes` value for a Datastore entity, pass in\n// an array for the key's data. The above example would then look like:\n//-\ndataset.save({\n  key: dataset.key('Company'),\n  data: [\n    {\n      name: 'rating',\n      value: '10',\n      excludeFromIndexes: false\n    }\n  ]\n}, function(err) {});\n\n//-\n// Save multiple entities at once.\n//-\nvar companyKey = dataset.key(['Company', 123]);\nvar productKey = dataset.key(['Product', 'Computer']);\n\ndataset.save([\n  {\n    key: companyKey,\n    data: {\n      HQ: 'Dallas, TX'\n    }\n  },\n  {\n    key: productKey,\n    data: {\n      vendor: 'Dell'\n    }\n  }\n], function(err) {});\n\n//-\n// Explicitly attempt to 'insert' a specific entity.\n//-\nvar userKey = dataset.key(['User', 'chilts']);\n\ndataset.save([\n  {\n    key: userKey,\n    method: 'insert', // force the method to 'insert'\n    data: {\n      fullName: 'Andrew Chilton'\n    }\n  }\n], function(err, apiResponse) {});",
        "html": "<p>//-<br />// Save a single entity.<br />//<br />// Notice that we are providing an incomplete key. After saving, the original<br />// Key object used to save will be updated to contain the path with its<br />// generated ID.<br />//-<br />var key = dataset.key(&#39;Company&#39;);</p><p>dataset.save({<br />  key: key,<br />  data: {<br />    rating: &#39;10&#39;<br />  }<br />}, function(err) {<br />  console.log(key.path); // [ &#39;Company&#39;, 5669468231434240 ]<br />  console.log(key.namespace); // undefined<br />});</p><p>//-<br />// Save a single entity using a provided name instead of auto-generated ID.<br />//<br />// Here we are providing a key with name instead of an ID. After saving, the<br />// original Key object used to save will be updated to contain the path with<br />// the name instead of a generated ID.<br />//-<br />var key = dataset.key([&#39;Company&#39;, &#39;donutshack&#39;]);</p><p>dataset.save({<br />  key: key,<br />  data: {<br />    name: &#39;DonutShack&#39;,<br />    rating: 8<br />  }<br />}, function(err) {<br />  console.log(key.path); // [&#39;Company&#39;, &#39;donutshack&#39;]<br />  console.log(key.namespace); // undefined<br />});</p><p>//-<br />// Save a single entity with a provided namespace. Namespaces allow for<br />// multitenancy. To read more about this, see<br />// <a href=\"https://goo.gl/M1LUAu\">the Datastore docs on key concepts</a>.<br />//<br />// Here we are providing a key with namespace.<br />//-<br />var key = dataset.key({<br />  namespace: &#39;my-namespace&#39;,<br />  path: [&#39;Company&#39;, &#39;donutshack&#39;]<br />});</p><p>dataset.save({<br />  key: key,<br />  data: {<br />    name: &#39;DonutShack&#39;,<br />    rating: 8<br />  }<br />}, function(err) {<br />  console.log(key.path); // [&#39;Company&#39;, &#39;donutshack&#39;]<br />  console.log(key.namespace); // &#39;my-namespace&#39;<br />});</p><p>//-<br />// Save different types of data, including ints, doubles, dates, booleans,<br />// blobs, and lists.<br />//<br />// Notice that we are providing an incomplete key. After saving, the original<br />// Key object used to save will be updated to contain the path with its<br />// generated ID.<br />//-<br />var key = dataset.key(&#39;Company&#39;);</p><p>dataset.save({<br />  key: key,<br />  data: {<br />    name: &#39;DonutShack&#39;, // strings<br />    rating: gcloud.datastore.int(8), // ints<br />    worth: gcloud.datastore.double(123456.78), // doubles<br />    numDonutsServed: 45, // detect number type (int or double)<br />    founded: new Date(&#39;Tue May 12 2015 15:30:00 GMT-0400 (EDT)&#39;), // dates<br />    isStartup: true, // booleans<br />    donutEmoji: new Buffer(&#39;\\uD83C\\uDF69&#39;), // buffers<br />    keywords: [ &#39;donut&#39;, &#39;coffee&#39;, &#39;yum&#39; ] // lists of objects<br />  }<br />}, function(err) {});</p><p>//-<br />// To specify an <code>excludeFromIndexes</code> value for a Datastore entity, pass in<br />// an array for the key&#39;s data. The above example would then look like:<br />//-<br />dataset.save({<br />  key: dataset.key(&#39;Company&#39;),<br />  data: [<br />    {<br />      name: &#39;rating&#39;,<br />      value: &#39;10&#39;,<br />      excludeFromIndexes: false<br />    }<br />  ]<br />}, function(err) {});</p><p>//-<br />// Save multiple entities at once.<br />//-<br />var companyKey = dataset.key([&#39;Company&#39;, 123]);<br />var productKey = dataset.key([&#39;Product&#39;, &#39;Computer&#39;]);</p><p>dataset.save([<br />  {<br />    key: companyKey,<br />    data: {<br />      HQ: &#39;Dallas, TX&#39;<br />    }<br />  },<br />  {<br />    key: productKey,<br />    data: {<br />      vendor: &#39;Dell&#39;<br />    }<br />  }<br />], function(err) {});</p><p>//-<br />// Explicitly attempt to &#39;insert&#39; a specific entity.<br />//-<br />var userKey = dataset.key([&#39;User&#39;, &#39;chilts&#39;]);</p><p>dataset.save([<br />  {<br />    key: userKey,<br />    method: &#39;insert&#39;, // force the method to &#39;insert&#39;<br />    data: {<br />      fullName: &#39;Andrew Chilton&#39;<br />    }<br />  }<br />], function(err, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Insert or update the specified object(s). If a key is incomplete, its<br />associated object is inserted and the original Key object is updated to<br />contain the generated ID.</p><p>This method will determine the correct Datastore method to execute (<code>upsert</code>,<br /><code>insert</code>, <code>update</code>, and <code>insertAutoId</code>) by using the key(s) provided. For<br />example, if you provide an incomplete key (one without an ID), the request<br />will create a new entity and have its ID automatically assigned. If you<br />provide a complete key, the entity will be updated with the data specified.</p><p>By default, all properties are indexed. To prevent a property from being<br />included in <em>all</em> indexes, you must supply an entity&#39;s <code>data</code> property as an<br />array. See below for an example.</p>",
      "summary": "<p>Insert or update the specified object(s). If a key is incomplete, its<br />associated object is inserted and the original Key object is updated to<br />contain the generated ID.</p>",
      "body": "<p>This method will determine the correct Datastore method to execute (<code>upsert</code>,<br /><code>insert</code>, <code>update</code>, and <code>insertAutoId</code>) by using the key(s) provided. For<br />example, if you provide an incomplete key (one without an ID), the request<br />will create a new entity and have its ID automatically assigned. If you<br />provide a complete key, the entity will be updated with the data specified.</p><p>By default, all properties are indexed. To prevent a property from being<br />included in <em>all</em> indexes, you must supply an entity&#39;s <code>data</code> property as an<br />array. See below for an example.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 165,
    "codeStart": 330,
    "code": "DatastoreRequest.prototype.save = function(entities, callback) {\n  entities = util.arrayize(entities);\n\n  var insertIndexes = [];\n\n  var req = {\n    mutation: entities.reduce(function(acc, entityObject, index) {\n      var ent = {};\n      var method = entityObject.method;\n      delete entityObject.method;\n\n      if (Array.isArray(entityObject.data)) {\n        ent.property = entityObject.data.map(function(data) {\n          data.value = entity.valueToProperty(data.value);\n\n          if (util.is(data.excludeFromIndexes, 'boolean')) {\n            var indexed = !data.excludeFromIndexes;\n\n            if (util.is(data.value.list_value, 'array')) {\n              data.value.list_value =\n                data.value.list_value.map(util.propAssign('indexed', indexed));\n            } else {\n              data.value.indexed = indexed;\n            }\n\n            delete data.excludeFromIndexes;\n          }\n\n          return data;\n        });\n      } else {\n        ent = entity.entityToEntityProto(entityObject.data);\n      }\n\n      ent.key = entity.keyToKeyProto(entityObject.key);\n\n      if (method) {\n        switch (method) {\n          case 'insert': {\n            acc.insert.push(ent);\n            break;\n          }\n          case 'update': {\n            acc.update.push(ent);\n            break;\n          }\n          case 'upsert': {\n            acc.upsert.push(ent);\n            break;\n          }\n          case 'insert_auto_id': {\n            insertIndexes.push(index);\n            acc.insert_auto_id.push(ent);\n            break;\n          }\n        }\n      } else {\n        if (entity.isKeyComplete(entityObject.key)) {\n          acc.upsert.push(ent);\n        } else {\n          insertIndexes.push(index);\n          acc.insert_auto_id.push(ent);\n        }\n      }\n\n      return acc;\n    }, {\n      insert: [],\n      update: [],\n      upsert: [],\n      insert_auto_id: []\n    })\n  };\n\n  if (this.id) {\n    this.requests_.push(req);\n    this.requestCallbacks_.push(onCommit);\n    return;\n  } else {\n    this.makeReq_('commit', req, onCommit);\n  }\n\n  function onCommit(err, resp) {\n    if (err || !resp) {\n      callback(err, resp);\n      return;\n    }\n\n    var autoInserted = (resp.mutation_result.insert_auto_id_key || []);\n    autoInserted.forEach(function(key, index) {\n      var path = entity.keyFromKeyProto(key).path;\n      entities[insertIndexes[index]].key.path = path;\n    });\n\n    callback(null, resp);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "save",
      "string": "DatastoreRequest.prototype.save()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Key|Key[]} key - Datastore key object(s).",
        "name": "key",
        "description": "<ul>\n<li>Datastore key object(s).</li>\n</ul>\n",
        "types": [
          "Key",
          "Array.<Key>"
        ],
        "typesDescription": "<a href=\"Key.html\">Key</a>|<code>Array</code>.&lt;<a href=\"Key.html\">Key</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use case, whether that be a Dataset or a Transaction object.\n//-\n\n// Delete a single entity.\ntransaction.delete(dataset.key(['Company', 123]), function(err, apiResp) {});\n\n// Delete multiple entities at once.\ntransaction.delete([\n  dataset.key(['Company', 123]),\n  dataset.key(['Product', 'Computer'])\n], function(err, apiResponse) {});",
        "html": "<p>//-<br />// Where you see <code>transaction</code>, assume this is the context that&#39;s relevant to<br />// your use case, whether that be a Dataset or a Transaction object.<br />//-</p><p>// Delete a single entity.<br />transaction.delete(dataset.key([&#39;Company&#39;, 123]), function(err, apiResp) {});</p><p>// Delete multiple entities at once.<br />transaction.delete([<br />  dataset.key([&#39;Company&#39;, 123]),<br />  dataset.key([&#39;Product&#39;, &#39;Computer&#39;])<br />], function(err, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Delete all entities identified with the specified key(s).</p>",
      "summary": "<p>Delete all entities identified with the specified key(s).</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 428,
    "codeStart": 449,
    "code": "DatastoreRequest.prototype.delete = function(keys, callback) {\n  callback = callback || util.noop;\n\n  var req = {\n    mutation: {\n      delete: util.arrayize(keys).map(entity.keyToKeyProto)\n    }\n  };\n\n  if (this.id) {\n    this.requests_.push(req);\n    return;\n  }\n\n  this.makeReq_('commit', req, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "delete",
      "string": "DatastoreRequest.prototype.delete()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{module:datastore/query} q - Query object.",
        "name": "q",
        "description": "<ul>\n<li>Query object.</li>\n</ul>\n",
        "types": [
          "module:datastore/query"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fquery.html\">datastore/query</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function=} callback - The callback function. If omitted, a readable\n    stream instance is returned.",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. If omitted, a readable     stream instance is returned.</li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?error} callback.err - An error returned while making this request\n    (may be null).",
        "name": "callback.err",
        "description": "<ul>\n<li>An error returned while making this request     (may be null).</li>\n</ul>\n",
        "types": [
          "error"
        ],
        "typesDescription": "<code>error</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{array} callback.entities - The list of entities returned by this\n    query. Note that this is a single page of entities, not necessarily\n    all of the entities.",
        "name": "callback.entities",
        "description": "<ul>\n<li>The list of entities returned by this     query. Note that this is a single page of entities, not necessarily<br />  all of the entities.</li>\n</ul>\n",
        "types": [
          "array"
        ],
        "typesDescription": "<code>array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?module:datastore/query} callback.nextQuery - If present, run another\n    query with this object to check for more results.",
        "name": "callback.nextQuery",
        "description": "<ul>\n<li>If present, run another     query with this object to check for more results.</li>\n</ul>\n",
        "types": [
          "module:datastore/query"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fquery.html\">datastore/query</a>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object} callback.apiResponse - The full API response.\n",
        "name": "callback.apiResponse",
        "description": "<ul>\n<li>The full API response. </li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or a Transaction object.\n//-\nvar query = dataset.createQuery('Lion');\n\ntransaction.runQuery(query, function(err, entities) {\n  if (!err) {\n    // Handle entities here.\n  }\n});\n\n//-\n// To control how many API requests are made and page through the results\n// manually, call `autoPaginate(false)` on your query.\n//-\nvar manualPageQuery = dataset.createQuery('Lion').autoPaginate(false);\n\nvar callback = function(err, entities, nextQuery, apiResponse) {\n  if (nextQuery) {\n    // More results might exist.\n    transaction.runQuery(nextQuery, callback);\n  }\n};\n\ntransaction.runQuery(manualPageQuery, callback);\n\n//-\n// If you omit the callback, runQuery will automatically call subsequent\n// queries until no results remain. Entity objects will be pushed as they are\n// found.\n//-\ntransaction.runQuery(query)\n  .on('error', console.error)\n  .on('data', function (entity) {})\n  .on('end', function() {\n    // All entities retrieved.\n  });\n\n//-\n// A keys-only query returns just the keys of the result entities instead of\n// the entities themselves, at lower latency and cost.\n//-\nvar keysOnlyQuery = dataset.createQuery('Lion').select('__key__');\n\ntransaction.runQuery(keysOnlyQuery, function(err, entities) {\n  // entities[].key = Key object\n  // entities[].data = Empty object\n});",
        "html": "<p>//-<br />// Where you see <code>transaction</code>, assume this is the context that&#39;s relevant to<br />// your use, whether that be a Dataset or a Transaction object.<br />//-<br />var query = dataset.createQuery(&#39;Lion&#39;);</p><p>transaction.runQuery(query, function(err, entities) {<br />  if (!err) {<br />    // Handle entities here.<br />  }<br />});</p><p>//-<br />// To control how many API requests are made and page through the results<br />// manually, call <code>autoPaginate(false)</code> on your query.<br />//-<br />var manualPageQuery = dataset.createQuery(&#39;Lion&#39;).autoPaginate(false);</p><p>var callback = function(err, entities, nextQuery, apiResponse) {<br />  if (nextQuery) {<br />    // More results might exist.<br />    transaction.runQuery(nextQuery, callback);<br />  }<br />};</p><p>transaction.runQuery(manualPageQuery, callback);</p><p>//-<br />// If you omit the callback, runQuery will automatically call subsequent<br />// queries until no results remain. Entity objects will be pushed as they are<br />// found.<br />//-<br />transaction.runQuery(query)<br />  .on(&#39;error&#39;, console.error)<br />  .on(&#39;data&#39;, function (entity) {})<br />  .on(&#39;end&#39;, function() {<br />    // All entities retrieved.<br />  });</p><p>//-<br />// A keys-only query returns just the keys of the result entities instead of<br />// the entities themselves, at lower latency and cost.<br />//-<br />var keysOnlyQuery = dataset.createQuery(&#39;Lion&#39;).select(&#39;<strong>key</strong>&#39;);</p><p>transaction.runQuery(keysOnlyQuery, function(err, entities) {<br />  // entities[].key = Key object<br />  // entities[].data = Empty object<br />});</p>"
      }
    ],
    "description": {
      "full": "<p>Datastore allows you to query entities by kind, filter them by property<br />filters, and sort them by a property name. Projection and pagination are also<br />supported.</p><p>If you provide a callback, the query is run, and the results are returned as<br />the second argument to your callback. A third argument may also exist, which<br />is a query object that uses the end cursor from the previous query as the<br />starting cursor for the next query. You can pass that object back to this<br />method to see if more results exist.</p><p>You may also omit the callback to this function to trigger streaming mode.</p><p>See below for examples of both approaches.</p>",
      "summary": "<p>Datastore allows you to query entities by kind, filter them by property<br />filters, and sort them by a property name. Projection and pagination are also<br />supported.</p>",
      "body": "<p>If you provide a callback, the query is run, and the results are returned as<br />the second argument to your callback. A third argument may also exist, which<br />is a query object that uses the end cursor from the previous query as the<br />starting cursor for the next query. You can pass that object back to this<br />method to see if more results exist.</p><p>You may also omit the callback to this function to trigger streaming mode.</p><p>See below for examples of both approaches.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 466,
    "codeStart": 544,
    "code": "DatastoreRequest.prototype.runQuery = function(query, callback) {\n  var req = {\n    read_options: {},\n    query: entity.queryToQueryProto(query)\n  };\n\n  if (query.namespace) {\n    req.partition_id = {\n      namespace: query.namespace\n    };\n  }\n\n  this.makeReq_('runQuery', req, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var entities = entity.formatArray(resp.batch.entity_result);\n    var nextQuery = null;\n\n    if (resp.batch.end_cursor && entities.length > 0) {\n      var endCursor = resp.batch.end_cursor.toBase64();\n      nextQuery = query.start(endCursor).offset(0);\n    }\n\n    callback(null, entities, nextQuery, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "runQuery",
      "string": "DatastoreRequest.prototype.runQuery()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Key} incompleteKey - The key object to complete.",
        "name": "incompleteKey",
        "description": "<ul>\n<li>The key object to complete.</li>\n</ul>\n",
        "types": [
          "Key"
        ],
        "typesDescription": "<a href=\"Key.html\">Key</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{number} n - How many IDs to generate.",
        "name": "n",
        "description": "<ul>\n<li>How many IDs to generate.</li>\n</ul>\n",
        "types": [
          "number"
        ],
        "typesDescription": "<code>number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or a Transaction object.\n//-\n\nvar incompleteKey = dataset.key(['Company']);\n\n// The following call will create 100 new IDs from the Company kind, which\n// exists under the default namespace.\ntransaction.allocateIds(incompleteKey, 100, function(err, keys) {});\n\n// You may prefer to create IDs from a non-default namespace by providing an\n// incomplete key with a namespace. Similar to the previous example, the call\n// below will create 100 new IDs, but from the Company kind that exists under\n// the \"ns-test\" namespace.\nvar incompleteKey = dataset.key({\n  namespace: 'ns-test',\n  path: ['Company']\n});\nvar callback = function(err, keys, apiResponse) {};\ntransaction.allocateIds(incompleteKey, 100, callback);",
        "html": "<p>//-<br />// Where you see <code>transaction</code>, assume this is the context that&#39;s relevant to<br />// your use, whether that be a Dataset or a Transaction object.<br />//-</p><p>var incompleteKey = dataset.key([&#39;Company&#39;]);</p><p>// The following call will create 100 new IDs from the Company kind, which<br />// exists under the default namespace.<br />transaction.allocateIds(incompleteKey, 100, function(err, keys) {});</p><p>// You may prefer to create IDs from a non-default namespace by providing an<br />// incomplete key with a namespace. Similar to the previous example, the call<br />// below will create 100 new IDs, but from the Company kind that exists under<br />// the &quot;ns-test&quot; namespace.<br />var incompleteKey = dataset.key({<br />  namespace: &#39;ns-test&#39;,<br />  path: [&#39;Company&#39;]<br />});<br />var callback = function(err, keys, apiResponse) {};<br />transaction.allocateIds(incompleteKey, 100, callback);</p>"
      }
    ],
    "description": {
      "full": "<p>Generate IDs without creating entities.</p>",
      "summary": "<p>Generate IDs without creating entities.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 574,
    "codeStart": 604,
    "code": "DatastoreRequest.prototype.allocateIds = function(incompleteKey, n, callback) {\n  if (entity.isKeyComplete(incompleteKey)) {\n    throw new Error('An incomplete key should be provided.');\n  }\n\n  var incompleteKeys = [];\n  for (var i = 0; i < n; i++) {\n    incompleteKeys.push(entity.keyToKeyProto(incompleteKey));\n  }\n\n  var req = {\n    key: incompleteKeys\n  };\n\n  this.makeReq_('allocateIds', req, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var keys = (resp.key || []).map(entity.keyFromKeyProto);\n\n    callback(null, keys, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "allocateIds",
      "string": "DatastoreRequest.prototype.allocateIds()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>update</code>.</p>",
      "summary": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>update</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 630,
    "codeStart": 633,
    "code": "DatastoreRequest.prototype.update = function(entities, callback) {\n  entities = util.arrayize(entities).map(util.propAssign('method', 'update'));\n  this.save(entities, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "update",
      "string": "DatastoreRequest.prototype.update()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>upsert</code>.</p>",
      "summary": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>upsert</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 638,
    "codeStart": 641,
    "code": "DatastoreRequest.prototype.upsert = function(entities, callback) {\n  entities = util.arrayize(entities).map(util.propAssign('method', 'upsert'));\n  this.save(entities, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "upsert",
      "string": "DatastoreRequest.prototype.upsert()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} method - Datastore action (allocateIds, commit, etc.).",
        "name": "method",
        "description": "<ul>\n<li>Datastore action (allocateIds, commit, etc.).</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object=} body - Request configuration object.",
        "name": "body",
        "description": "<ul>\n<li>Request configuration object.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "private",
        "string": "\n",
        "visibility": "private",
        "html": ""
      },
      {
        "type": "example",
        "string": "var deleteRequest = {\n  mutation: {\n    delete: [] // datastore key objects.\n  }\n};\n\nvar dataset = gcloud.datastore.dataset({ projectId: 'project-id' });\nvar callback = function(err, result, apiResponse) {};\nvar Transaction = require('gcloud/lib/datastore/transaction');\nvar transaction = new Transaction(dataset, 'my-project-id');\ntransaction.makeReq_('commit', deleteRequest, callback);",
        "html": "<p>var deleteRequest = {<br />  mutation: {<br />    delete: [] // datastore key objects.<br />  }<br />};</p><p>var dataset = gcloud.datastore.dataset({ projectId: &#39;project-id&#39; });<br />var callback = function(err, result, apiResponse) {};<br />var Transaction = require(&#39;gcloud/lib/datastore/transaction&#39;);<br />var transaction = new Transaction(dataset, &#39;my-project-id&#39;);<br />transaction.makeReq_(&#39;commit&#39;, deleteRequest, callback);</p>"
      }
    ],
    "description": {
      "full": "<p>Make a request to the API endpoint. Properties to indicate a transactional or<br />non-transactional operation are added automatically.</p>",
      "summary": "<p>Make a request to the API endpoint. Properties to indicate a transactional or<br />non-transactional operation are added automatically.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 646,
    "codeStart": 669,
    "code": "DatastoreRequest.prototype.makeReq_ = function(method, body, callback) {\n  // TODO: Handle non-HTTP 200 cases.\n  if (!callback) {\n    callback = body;\n    body = {};\n  }\n\n  callback = callback || util.noop;\n\n  // Set properties to indicate if we're in a transaction or not.\n  if (method === 'commit') {\n    if (this.id) {\n      body.mode = MODE_TRANSACTIONAL;\n      body.transaction = this.id;\n    } else {\n      body.mode = MODE_NON_TRANSACTIONAL;\n    }\n  }\n\n  if (method === 'rollback') {\n    body.transaction = this.id;\n  }\n\n  if (method === 'lookup' && this.id) {\n    body.read_options = body.read_options || {};\n    body.read_options.transaction = this.id;\n  }\n\n  var pbKey = method[0].toUpperCase() + method.substr(1);\n  var pbRequest = new pb[pbKey + 'Request'](body).toBuffer();\n  var pbResponse = pb[pbKey + 'Response'];\n\n  var reqOpts = {\n    method: 'POST',\n    uri: util.format('{apiEndpoint}/{path}/{projectId}/{method}', {\n      apiEndpoint: this.apiEndpoint,\n      path: 'datastore/v1beta2/datasets',\n      projectId: this.projectId,\n      method: method\n    }),\n    headers: {\n      'Content-Type': 'application/x-protobuf'\n    }\n  };\n\n  this.makeAuthorizedRequest_(reqOpts, {\n    onAuthorized: function(err, authorizedReqOpts) {\n      if (err) {\n        callback(err, null); // TODO(ryanseys): What goes as third parameter?\n        return;\n      }\n\n      authorizedReqOpts.headers = authorizedReqOpts.headers || {};\n      authorizedReqOpts.headers['Content-Length'] = pbRequest.length;\n\n      var apiRequest = request(authorizedReqOpts);\n\n      apiRequest.on('error', callback);\n\n      apiRequest.on('response', function(resp) {\n        var buffer = new Buffer('');\n        resp.on('data', function(chunk) {\n          buffer = Buffer.concat([buffer, chunk]);\n        });\n        resp.on('end', function() {\n          util.handleResp(null, resp, buffer.toString(), function(err, result) {\n            if (err) {\n              callback(err, null, result);\n              return;\n            }\n            callback(null, pbResponse.decode(buffer), result);\n          });\n        });\n      });\n\n      apiRequest.end(pbRequest);\n    }\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "makeReq_",
      "string": "DatastoreRequest.prototype.makeReq_()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Developer Documentation</p><p>This method can be used with either a callback or as a readable object<br />stream. <code>streamRouter</code> is used to add this dual behavior.</p>",
      "summary": "<p>Developer Documentation</p>",
      "body": "<p>This method can be used with either a callback or as a readable object<br />stream. <code>streamRouter</code> is used to add this dual behavior.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 749,
    "codeStart": 754,
    "code": "streamRouter.extend(DatastoreRequest, 'runQuery');\n\nmodule.exports = DatastoreRequest;",
    "ctx": false
  }
]